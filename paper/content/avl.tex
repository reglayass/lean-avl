\notes{give a small introduction to the section}

\subsection{Binary Search Trees} 
\label{sec:bst}
I begin by defining a binary search tree. A binary tree is a tree data structure where each node can have no more than two children. These two children are 
called the \textit{left child} and the \textit{right child} subtrees. In a binary \textit{search} tree, nodes are placed according to their key. 

Where nodes are placed in a binary search tree is determined by what is often called the \textit{binary search property}.

\begin{definition}[Binary Search Property]
  \label{def:bst_property}
  Given any node N in a binary search tree, all the keys in the left child subtree are smaller than that of N, and all keys in the right child subtree are greater than the 
  key of N.
\end{definition}

This allows for lookup and insertion to be done in \notes{add complexity here} time in the worst case, as at any given node half of the tree is skipped.

\begin{figure}[!h]
  \centering
  \begin{subfigure}{.3\textwidth}
    \centering
    \begin{tikzpicture}
      \node[circle,draw,fill=gray!30](z){5}
      child{ node[circle,draw]{4} }
      child{
        node[circle,draw]{6} child[missing] child[missing] };
    \end{tikzpicture}
    \caption{}
    \label{fig:insert_1}
  \end{subfigure}%
  \begin{subfigure}{.3\textwidth}
    \centering
    \begin{tikzpicture}
      \node[circle,draw](z){5}
      child{ node[circle, draw]{4} }
      child{
        node[circle,draw,fill=gray!30]{6} child[missing] child[missing] };
    \end{tikzpicture}
    \caption{}
    \label{fig:insert_2}
  \end{subfigure}%
  \begin{subfigure}{.3\textwidth}
    \centering
    \begin{tikzpicture}
      \node[circle,draw](z){5}
      child{ node[circle, draw]{4} }
      child{
        node[circle,draw]{6} child[missing] child{node[circle,draw,fill=gray!30]{7}} };
    \end{tikzpicture}
    \caption{}
    \label{fig:insert_3}
  \end{subfigure}
  \caption{Insertion operation in a binary search tree.}
  \label{fig:insert_demo}
\end{figure}

Search, insertion and retrieval can be done recursively. Starting at the root node, the input key and the node key are compared: if the input key is smaller,
the operation is done recursively on the left subtree; if the input key is larger, then the operation is done recursively on the right subtree. Figure \ref{fig:insert_demo} shows 
a node with key 7 being inserted into a binary search tree. At \ref{fig:insert_demo}(\ref{sub@fig:insert_1}), the new node is compared to the root. As $7 > 5$, the operation continues at 
the right subtree. At \ref{fig:insert_demo}(\ref{sub@fig:insert_2}) the comparison is done again. As $7 > 6$, the operation continues at the right subtree. Because the node 6 doesn't have any children and $7 > 6$,
a new right child node is created.

\subsection{Balance and rotation}
An AVL tree is based on a binary search tree, with one very important distinction - it is \textit{balanced}. To define what it means for a tree to be balanced, I will first
define what the \textit{height} of a tree is.

\begin{definition}[Tree height]
  \label{def:height}
  The height of a tree is the length of the longest path from the root to a leaf.
\end{definition} 
 
Balance is reliant on this definition - an AVL tree is only balanced when the 
heights of any given left and right child subtrees does not differ by more than one \cite{avl:original}. By keeping balance, the structure ensures that there is a high ratio between the number of 
nodes in the tree and the height. This allows for retrieval and search operations to be done in $O(\log n)$ time in the worst case, with $n$ being the amount of nodes in a tree \cite{avl:computer}.

During the insertion operation, the tree can become imbalanced, which can be mitigated
with either a right rotation or a left rotation. 