\section{Formalization}

\subsection{Simple BST}
The first step to formalizing an AVL tree was to formalize a simple binary search tree. Even though Lean has a definition of a basic binary tree 
\lstinline{bin_tree}, that definition does not include a node key. For a binary search tree, this is important, so the inductive type for this formalization includes 
both a key and a value for each node.

\begin{figure}[!ht]
  \lstinputlisting[language=lean, firstline=3, lastline=5, frame=single]{/Users/sofiakonovalova/Desktop/Thesis/lean-thesis/src/basic.lean}
  \caption{}
  \label{fig:btree_simple}
\end{figure}

Figure \ref{fig:btree_simple} shows the inductive type for the binary tree. This simple simple tree has two
constructors: an empty binary tree, and a node with a left and right subtree, a key and a node value.

Figure \ref{fig:lookup_simple} shows a simple lookup operation. As mentioned before, nodes in a binary search tree are ordered; all keys in the left child subtree are smaller than the root,
and all keys in the right child subtree are larger than the root. Therefore when looking up a key in the tree, we need to do a comparison. If the key that is being looked up is smaller, then do a recursive lookup
on the left subtree; if it is larger, then do a recursive lookup on the right subtree. If the key is neither larger nor smaller, than we have found the key.

The \lstinline{bound} is very similar to \lstinline{lookup}. The definition checks if a key exists in the tree.

\begin{figure}[!ht]
  \lstinputlisting[language=lean, firstline=12, lastline=17, frame=single]{/Users/sofiakonovalova/Desktop/Thesis/lean-thesis/src/basic.lean}
  \caption{}
  \label{fig:lookup_simple}
\end{figure}

\begin{figure}[!ht]
  \lstinputlisting[language=lean, firstline=19, lastline=24, frame=single]{/Users/sofiakonovalova/Desktop/Thesis/lean-thesis/src/basic.lean}
  \caption{}
  \label{fig:bound_simple}
\end{figure}

The insertion operation also does key comparisons in order to pick which child subtree to enter the new node into. If the new key is smaller than the 
key of the current tree node, the insertion is done recursively on the left subtree; if the new key is larger, then insertion is done recursively on the
right subtree.