A binary search tree (BST) -- also called an ordered tree -- is a tree that is either empty or is a node with up to two children, a node key and a value. The children are referred to as the \textit{left child} and \textit{right child}. 

In Lean, binary search trees are defined as the following inductive type.

\begin{lstlisting}
inductive btree (α : Type u)
| empty {} : btree
| node (l : btree) (k : nat) (a : α) (r : btree) : btree
\end{lstlisting}

This definition has two constructors: one for an empty tree, and one for a node. The node key is defined as a natural number. There is no leaf constructor, as a leaf is a node with no children, which can be defined with the \lstinline{node} constructor.

From there, I define a function to search for a key in a tree. This function, \lstinline{bound}, verifies that a key exists in a tree; therefore, it doesn't matter in which subtree it is located, as long as it is present in one of them.

\begin{lstlisting}
def bound (x : nat) : btree α → bool
| btree.empty := ff
| (btree.node l k a r) :=
  x = k ∨ bound l ∨ bound r
\end{lstlisting}

A binary search tree must have the \textit{binary search property}.

\begin{definition}[Binary Search Property]
  \label{def:bst_property}
  Given any node N in a binary search tree, all the keys in the left subtree of N are smaller than the key of N, and all keys in the right subtree are greater than the 
  key of N.
\end{definition}

In Lean we define the binary search tree property wih two separate definitions. The first one, \lstinline{forall_keys}, describes the relationship between a key and a tree -- for all the keys that exist in the tree, the type of relation on natural numbers \lstinline{nat → nat → Prop} (in this case, $>$ or $<$) holds for the input key and the keys in the tree.

\begin{lstlisting}
def forall_keys (p : nat → nat → Prop) (k : nat) (t : btree α) : Prop :=
  ∀ k', bound k' t → p k k'
\end{lstlisting}

The second definition, \lstinline{ordered}, formalizes the binary search property. A tree is only ordered if the children are ordered, and \lstinline{forall_keys} holds for the key being larger than the keys in the left subtree and the key being smaller than the keys in the right subtree.

\begin{lstlisting}
def ordered : btree α → Prop
| btree.empty := tt
| (btree.node l k a r) :=
  ordered l ∧ ordered r ∧ (forall_keys (>) k l) ∧ (forall_keys (<) k r)
\end{lstlisting}

The lookup operation is done recursively. During traversal, it is possible to compare every key to another one assuming that the keys are totally ordered. When traversing the tree, if the input key is smaller than the current node key, we recurse into the left subtree; if the input key is larger, we recurse into the right subtree. 

\begin{lstlisting}
def lookup (x : nat) : btree α → option α
| btree.empty := none
| (btree.node l k a r) :=
  if x < k 
    then lookup l
    else if x > k 
      then lookup r
    else a
\end{lstlisting}