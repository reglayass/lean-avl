This section will go through the proof construction of deletion preserving order, and the sub-proofs that come along with it as well as major changes that have been done to previous definitions to make the proof constructions easier and readable. The lemma statements closely follow the ones presented in \cite{textbook:discrete_computer}, though in the process some definitions were changed.

The lemma statement for deletion preserving order is formalized below.

\begin{lstlisting}
lemma delete_ordered (t : btree α) (k : nat) :
  ordered t → ordered (delete k t) := ...
\end{lstlisting}

Since the function \lstinline{delete} uses \lstinline{del_node}, and \lstinline{del_node} uses \lstinline{shrink}, proofs about the two preserving order need to be sontructed as well.

\begin{lstlisting}
lemma del_node_ordered (t : btree α) (k : nat) :
  ordered t → ordered (del_node t) := ...

lemma shrink_ordered {t sh : btree α} {x : nat} {a : α} :
  ordered t ∧ shrink t = some (x, a, sh) →
    ordered sh ∧ forall_keys gt x sh := ...
\end{lstlisting}

The proof statement for \lstinline{shrink_ordered} needs to have the reuslt of \lstinline{shrink} as one of its hypotheses, and the conclusion is that the result of shrinking a tree is also ordered, and that the resulting key is larger than the keys in the shrunken tree.

The proof for \lstinline{shrink_ordered} was done by induction on the tree, but generalizing \lstinline{x}, \lstinline{a} and \lstinline{sh}. This is because without the generalization, the proof would be referring to a specific result of \lstinline{shrink}, which cannot be foreseen, so therefore the proof needs to take into account all the possible values for the three-tuple result of \lstinline{shrink}. The proof for \lstinline{delete} was completed with induction on \lstinline{t} and \lstinline{del_node} was completed with a case split.

To aid with writing the proofs, two view inductive definitions were written for \lstinline{shrink} and \lstinline{delete}\footnote{The idea for this view type was created by the daily supervisor, Jannis Limperg}. The \lstinline{shrink_view} is shown below.

\begin{lstlisting}
inductive shrink_view {α} : btree α → option (nat × α × btree α) → Sort*
| empty : shrink_view empty none
| nonempty_empty : ∀ {l k v r},
  shrink r = none →
  shrink_view (node l k v r) (some (k, v, l))
| nonempty_nonempty₁ : ∀ {l k v r x a sh out},
  shrink r = some (x, a, sh) →
  height l > height sh + 1 →
  out = some (x, a, rotate_right (btree.node l k v sh)) →
  shrink_view (node l k v r) out
| nonempty_nonempty₂ : ∀ {l k v r x a sh},
  shrink r = some (x, a, sh) →
  height l ≤ height sh + 1 →
  shrink_view (node l k v r) (some (x, a, node l k v sh))
\end{lstlisting}

A lemma was also written for \lstinline{shrink_view}, that would result in case splits for each case in the view. 

\begin{lstlisting}
lemma shrink_shrink_view (t : btree α) : 
  shrink_view t (shrink t) := ...
\end{lstlisting}

Applying the lemma would result in three cases in the inductive step of \lstinline{shrink_ordered}. The same steps were taken for \lstinline{del_node}, writing a view definition and then a lemma that would deconstruct it from a normal \lstinline{del_node} definition.

A lemma for \lstinline{shrink} retaining keys also needed to be written, as the proof needs to also show that \lstinline{x} is a key from the tree \lstinline{t} and not some random key.

\begin{lstlisting}
lemma shrink_keys {t sh : btree α} {x : nat} {a : α} :
  ordered t → shrink t = some (x, a, sh) → 
    bound x t ∧ (∀ k', bound k' sh → bound k' t) := ...
\end{lstlisting}

As \lstinline{shrink_keys} would have to be applied to \lstinline{shrink_ordered}, the original \lstinline{forall_keys} definition had to be rewritten. Before beginning the proofs about deletion, the \lstinline{forall_keys} definition was \lstinline{forall_keys_unfolded} as seen in Section \ref{sec:bst}, without the additional definition to take into account the key being bound in the tree. After the new definition was written, an introduction lemma was needed in order to split a goal with \lstinline{forall_keys} intro three goals. 

First, two lemmas were created in order to verify that the two definitions \lstinline{forall_keys} and \lstinline{forall_keys_unfolded} were the same. 

\begin{lstlisting}
lemma forall_keys_unfolded_bound (t : btree α) 
(p : nat → nat → Prop) (k : nat) :
  forall_keys_unfolded p k t → forall_keys p k t := ...

lemma forall_keys_bound_unfolded (t : btree α) 
(p : nat → nat → Prop) (k : nat) :
  forall_keys p k t → forall_keys_unfolded p k t :=
\end{lstlisting}

Then, the final introduction lemma was written and the proof completed. 

\begin{lstlisting}
lemma forall_keys_intro {l r : btree α} {k x : nat} {v : α} 
{p : nat → nat → Prop} :
  (forall_keys p k l ∧ p k x ∧ forall_keys p k r) → 
    forall_keys p k (node l x v r) :=
\end{lstlisting}