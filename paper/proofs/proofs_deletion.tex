This section will follow a proof construction of deletion from a tree preserving order. The lemma statements presented in this section closely follow \cite{textbook:discrete_computer}, though in the process some of the statements were made to suit the Lean definitions.

\begin{lstlisting}
lemma delete_ordered (t : btree α) (k : nat) :
  ordered t → ordered (delete k t) := ...
\end{lstlisting}

This proof is constructed with a simple proof by induction. 

Since the function \lstinline{delete} uses \lstinline{del_node}, and \lstinline{del_node} uses \lstinline{shrink}, proofs about the two preserving order need to be sontructed as well.

\begin{lstlisting}
lemma del_node_ordered (t : btree α) (k : nat) :
  ordered t → ordered (del_node t) := ...
\end{lstlisting}

The proof for \lstinline{del_node} was done with a simple case split on the tree.

The proof for shrink needs to have a bit more information in the hypotheses. It's not enough to say that \lstinline{t} is ordered and \lstinline{sh} is ordered, there needs to be a connection between the tree and the shrunken tree, so \lstinline{shrink t = some (x, a, sh)} is one of the hypotheses of the proof. The proof also shows that \lstinline{x} is larger than all of the keys in a shrunken tree. 

\begin{lstlisting}
lemma shrink_ordered {t sh : btree α} {x : nat} {a : α} :
  ordered t ∧ shrink t = some (x, a, sh) →
    ordered sh ∧ forall_keys gt x sh := ...
\end{lstlisting}

The proof for \lstinline{shrink_ordered} was done by induction on the tree generalizing \lstinline{x}, \lstinline{a} and \lstinline{sh}, as the proof construction this way will take into account all possible values of the three.

To aid with writing the proofs, two view inductive definitions were written for \lstinline{shrink} and \lstinline{delete}\footnote{The idea for this view type was created by the daily supervisor, Jannis Limperg}. The \lstinline{shrink_view} is shown below.

\begin{lstlisting}
inductive shrink_view {α} : btree α → option (nat × α × btree α) → Sort*
| empty : shrink_view empty none
| nonempty_empty : ∀ {l k v r},
  shrink r = none →
  shrink_view (node l k v r) (some (k, v, l))
| nonempty_nonempty₁ : ∀ {l k v r x a sh out},
  shrink r = some (x, a, sh) →
  height l > height sh + 1 →
  out = some (x, a, rotate_right (btree.node l k v sh)) →
  shrink_view (node l k v r) out
| nonempty_nonempty₂ : ∀ {l k v r x a sh},
  shrink r = some (x, a, sh) →
  height l ≤ height sh + 1 →
  shrink_view (node l k v r) (some (x, a, node l k v sh))
\end{lstlisting}

These views allowed for a case split on \lstinline{shrink} or \lstinline{del_node} without additional manual case-splits on subtrees.

A lemma was also written for \lstinline{shrink_view}, that would result in case splits for each case in the view. 

\begin{lstlisting}
lemma shrink_shrink_view (t : btree α) : 
  shrink_view t (shrink t) := ...
\end{lstlisting}

Applying the lemma would result in three cases in the inductive step of \lstinline{shrink_ordered}. The same steps were taken for \lstinline{del_node}, writing a view definition and then a lemma that would deconstruct it from a normal \lstinline{del_node} definition.

A lemma for \lstinline{shrink} retaining keys also needed to be written, as the proof needs to also show that \lstinline{x} is a key from the tree \lstinline{t} and not some random key.

\begin{lstlisting}
lemma shrink_keys {t sh : btree α} {x : nat} {a : α} :
  ordered t → shrink t = some (x, a, sh) → 
    bound x t ∧ (∀ k', bound k' sh → bound k' t) := ...
\end{lstlisting}

As \lstinline{shrink_keys} would have to be applied to \lstinline{shrink_ordered}, the original \lstinline{forall_keys} definition had to be rewritten. Before beginning the proofs about deletion, the \lstinline{forall_keys} definition was \lstinline{forall_keys_unfolded} as seen in Section \ref{sec:bst}, without the additional definition to take into account the key being bound in the tree. After the new definition was written, an introduction lemma was needed in order to split a goal with \lstinline{forall_keys} intro three goals. 

First, two lemmas were created in order to verify that the two definitions \lstinline{forall_keys} and \lstinline{forall_keys_unfolded} were the same. 

\begin{lstlisting}
lemma forall_keys_unfolded_bound (t : btree α) 
(p : nat → nat → Prop) (k : nat) :
  forall_keys_unfolded p k t → forall_keys p k t := ...

lemma forall_keys_bound_unfolded (t : btree α) 
(p : nat → nat → Prop) (k : nat) :
  forall_keys p k t → forall_keys_unfolded p k t :=
\end{lstlisting}

Then, the final introduction lemma was written and the proof completed. 

\begin{lstlisting}
lemma forall_keys_intro {l r : btree α} {k x : nat} {v : α} 
{p : nat → nat → Prop} :
  (forall_keys p k l ∧ p k x ∧ forall_keys p k r) → 
    forall_keys p k (node l x v r) :=
\end{lstlisting}