This section details the steps taken to write a proof for deletion preserving order. Similar to proofs about rotations, if we want to prove deletion preserving order, any other definition that \lstinline{delete} uses will have a lemma regarding order as well. Due to the way that \lstinline{ordered} is defined with \lstinline{forall_keys}, lemmas about boundedness are involved as well. Just from writing one lemma about deletion preserving order, we receive lemmas about key preservation as well, that can be used for other proofs. First we follow the steps taken to write the lemmas for order, then lemmas about key preservation are discussed specifically. Lastly, any design changes or additions made during this process are presented.

\subsection*{Order}
 
We begin with the lemma statement for deletion of a key and deletion of a root node preserving order.

\begin{lstlisting}
lemma delete_ordered (t : btree α) (k : nat) :
  ordered t → ordered (delete k t) := ...

lemma del_root_ordered (t : btree α) :
  ordered t → ordered (del_root t) := ...
\end{lstlisting}

The proof for \lstinline{delete_ordered} was constructed with induction on \lstinline{t}, and \lstinline{del_root} was completed with a case split on \lstinline{t}.

The next step is to complete the proof for \lstinline{shrink} preserving order. The proof for shrink needs to contain more information, as we cannot simply state that \lstinline{t} is ordered and therefore \lstinline{sh} is ordered, there needs to be a link between the two trees. Therefore, hypotheses need to contain the result of shrinking the tree, \lstinline{shrink t = some (x, a, sh)}, and that the entire tree is ordered and therefore so is \lstinline{sh}. The proof also concludes that \lstinline{x} is larger than all of the keys in a shrunken tree.

\begin{lstlisting}
lemma shrink_ordered {t sh : btree α} {x : nat} {a : α} :
  ordered t ∧ shrink t = some (x, a, sh) →
    ordered sh ∧ forall_keys gt x sh := ...
\end{lstlisting}

This lemma, could have been be split into two separate lemmas with one concluding that \lstinline{sh} is ordered and that \lstinline{x} is greater than all keys in \lstinline{sh}. If the lemma was to be separated into two, the induction hypotheses would not be strong enough to complete the proofs.

The proof for \lstinline{shrink_ordered} was done by induction on the tree generalizing \lstinline{x}, \lstinline{a} and \lstinline{sh}.

In the inductive step, if the left subtree is larger than the height of \lstinline{sh + 1}, then \lstinline{sh = rotate_right (node l k v sh_1)}, where \lstinline{sh_1} is from \lstinline{shrink r = (x_1, a_1, sh_1)}. This case can be resolved with the lemma \lstinline{rotate_right_keys} to show that keys are preserved after a rotation. Then we need to show that all the keys in \lstinline{sh} come from the original tree, which is done by applying the lemma \lstinline{shrink_keys}.

\begin{lstlisting}
lemma shrink_keys {t sh : btree α} {x : nat} {a : α} :
  ordered t ∧ shrink t = some (x, a, sh) → 
    bound x t ∧ (∀ k', bound k' t → bound k' sh) := ...
\end{lstlisting}

We know that \lstinline{x_1} is larger than all the keys in \lstinline{sh_1}. Since \lstinline{(node l k v sh_1)} is ordered, then it must be the case that \lstinline{k} is smaller than all the keys in \lstinline{sh_1}, and therefore \lstinline{x > k} and \lstinline{x} is greater than all the keys in \lstinline{l}. This is formalized using the auxiliary lemma \lstinline{forall_shrink}.

\begin{lstlisting}
lemma forall_shrink {t sh : btree α} {k x : nat} {a : α} 
{p : nat → nat → Prop} :
  forall_keys p k t ∧ shrink t = some (x, a, sh) → 
    forall_keys p k sh ∧ p k x :=
\end{lstlisting}

As \lstinline{shrink_keys} would have to be applied to \lstinline{shrink_ordered}, the original \lstinline{forall_keys} definitions had to be rewritten. The original definition, \lstinline{forall_keys_unfolded}, was a recursive one that looked at the relation of the key to the left and right tree, and with the current node key. It presents nothing about the key being bound in the tree it has a relation with, even though it is a safe assumption to make. In order to use \lstinline{shrink_keys}, we need a definition of \lstinline{forall_keys} that includes the assumption of boundedness, but still compares the input key to keys in a tree. The result was the current definition of \lstinline{forall_keys}.

\begin{lstlisting}
def forall_keys_unfolded (p : nat → nat → Prop) : nat → btree α → Prop
| x btree.empty := tt
| x (btree.node l k a r) :=
  forall_keys_unfolded x l ∧ (p x k) ∧ forall_keys_unfolded x r
\end{lstlisting}

After the new definition was written, a characterization lemma was needed in order to be able to work with the two different definitions, because we don't necessarily need the hypothesis that the keys compared are bound in the tree in all the proof constructions, or even in the entire proof construction.

The characterization lemma being a bi-implication allows for the lemma to be applied to any hypothesis containing a \lstinline{forall_keys}, to extract information about the subtrees separately and the relationship between \lstinline{k} and \lstinline{x}. This made proof constructions with \lstinline{forall_keys} significantly easier, as there was an alternative way to unfold \lstinline{forall_keys}, instead of unfolding it in terms of \lstinline{bound} like in the definition. 

\begin{lstlisting}
lemma forall_keys_ch {l r : btree α} {k x : nat} {v : α} 
{p : nat → nat → Prop} :
  (forall_keys p k l ∧ p k x ∧ forall_keys p k r) ↔ 
    forall_keys p k (node l x v r) :=
\end{lstlisting}

\subsection*{Views}

During most proof constructions presented in this section, I simplified definitions to extract information, or create case splits. With \lstinline{shrink}, this process would be long and would clutter the proof. There needed to be a way to split the result of \lstinline{shrink} into the tree possible cases that can come out of shrinking a tree with one action, reducing any unnecessary writing. The same problem arose with \lstinline{del_node}. To solve these problems we define two views for \lstinline{shrink}\footnote{This approach was suggested by Jannis Limperg} and \lstinline{del_node}. The \lstinline{shrink_view} is shown below.

\begin{lstlisting}
inductive shrink_view {α} : btree α → option (nat × α × btree α) → Sort*
| empty : shrink_view empty none
| nonempty_empty : ∀ {l k v r},
  shrink r = none →
  shrink_view (node l k v r) (some (k, v, l))
| nonempty_nonempty₁ : ∀ {l k v r x a sh out},
  shrink r = some (x, a, sh) →
  height l > height sh + 1 →
  out = some (x, a, rotate_right (btree.node l k v sh)) →
  shrink_view (node l k v r) out
| nonempty_nonempty₂ : ∀ {l k v r x a sh},
  shrink r = some (x, a, sh) →
  height l ≤ height sh + 1 →
  shrink_view (node l k v r) (some (x, a, node l k v sh))
\end{lstlisting}

The views have a constructor for each possible result of \lstinline{shrink} or \lstinline{del_node}. In the case where rotations are made, an adjustment had to be made in the form of the assumption \lstinline{out}. This was done because inductive types in Lean do not accept other function calls in the type constructor.

In order to use the views, auxiliary lemmas were written to apply a normal \lstinline{shrink} or \lstinline{del_node} and get the three case splits. The lemma for \lstinline{shrink_view} is shown below. The proof for \lstinline{del_node} is almost identical.

\begin{lstlisting}
lemma shrink_shrink_view (t : btree α) : 
  shrink_view t (shrink t) := ...
\end{lstlisting}

Applying the lemma would result in three cases in the inductive step of \lstinline{shrink_ordered}, which matches the three cases from the definition -- one for the right subtree being empty, leading to \lstinline{shrink r = none}, another one where \lstinline{shrink r = some (x, a, rotate_right(l k v sh))}, and another one where \lstinline{shrink r = some (x, a, node l k v sh)}. This allowed to complete the proofs without creating additional case splits, cluttering the proof construction.