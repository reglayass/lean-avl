For insertion, we want to show that keys, order and balance are preserved.

% For balance, there was some trouble constructing a proof for \lstinline{insert_balanced}, as the goal of this lemma is that balance is preserved, while the lemmas for rotations are about restoring balance. The two definitions are not very compatible with each other.

\subsection*{Key Preservation}
There are three different lemmas in relation to key preservation.

\begin{lstlisting}
lemma insert_bound (t : btree α) (k : nat) (v : α) :
  bound k (insert k v t) := ...

lemma insert_diff_bound (t : btree α) (k x : nat) (v : α) :
  bound x t → bound x (insert k v t) := ...

lemma insert_nbound (t : btree α) (k x : nat) (v : α) :
  (bound x t = ff ∧ x ≠ k) → bound x (insert k v t) = ff := ...
\end{lstlisting}

For \lstinline{insert_bound}, the goal is to show that a key can be found as soon as it is inserted into a tree. For \lstinline{insert_diff_bound} and \lstinline{insert_nbound}, the goal is to show that the keys already existing in a tree do not get lost during insertion, and if a key does not exist in a tree, unless it is the new key, it does not exist after insertion. The proofs are completed by induction on the tree \lstinline{t}.

Since \lstinline{insert} uses rotations, previously constructed proofs about rotations preserving keys are applied in these proofs. The tactic \lstinline{tauto} is used frequently, as the tactic is a decisional procedure for propositional logic and is able to split goals and assumptions that are disjunctions. Due to the \lstinline{bound} definition using disjunction, this tactic does a lot of the heavy work of breaking down these forms, and then completing the separate foals based on reflexivity.

\subsection*{Order}
Lemma statements for insertion preserving order have the same structure as lemmas for rotations preserving order.

\begin{lstlisting}
lemma insert_ordered (t : btree α) (k : nat) (v : α) :
  ordered t → ordered (insert k v t) := ...
\end{lstlisting}

This proof is constructed by induction on the tree \lstinline{t} and previous lemmas for rotations preserving order are applied. 

A new proof is constructed for \lstinline{forall_insert}, as during the proof construction above, we want to show that previously existing keys in a tree preserve their relation with the tree after insertion. To bring an example from the proof construction of \lstinline{insert_ordered} -- if a key \lstinline{tk} is greater than all of the keys in the tree \lstinline{tl} even after insertion, then it follows that \lstinline{tk > k} and that \lstinline{tk} is greater than all of the keys in \lstinline{tl}. These are also the sub-goals that come out after applying the lemma.

\begin{lstlisting}
lemma forall_insert (k x : nat) (t : btree α) (a : α) 
(p : nat → nat → Prop) (h : p x k) :
  forall_keys p x t → forall_keys p x (insert k a t) := ...
\end{lstlisting}

As insertion uses rotation, similar lemmas were written for both compound and simple rotations.

\begin{lstlisting}
lemma forall_rotate_right (x k : nat) (l r : btree α) (a : α) 
(p : nat → nat → Prop) :
  forall_keys p x (btree.node l k a r) → 
    forall_keys p x (rotate_right (btree.node l k a r)) := ...

lemma forall_rotate_right (x k : nat) (l r : btree α) (a : α) 
(p : nat → nat → Prop) :
  forall_keys p x (btree.node l k a r) → 
    forall_keys p x (simple_right (btree.node l k a r)) := ...
\end{lstlisting}

The three proofs above were constructed by induction on \lstinline{t}.