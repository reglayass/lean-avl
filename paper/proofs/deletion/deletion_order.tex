We begin with the lemma statement for deletion of a key and deletion of a root node preserving order.

\begin{lstlisting}
lemma delete_ordered (t : btree α) (k : nat) :
  ordered t → ordered (delete k t) := ...

lemma del_root_ordered (t : btree α) :
  ordered t → ordered (del_root t) := ...
\end{lstlisting}

The proof for \lstinline{delete_ordered} was constructed with induction on \lstinline{t}, and \lstinline{del_root} was completed with a case split on \lstinline{t}.

The next step is to complete the proof for \lstinline{shrink} preserving order. The proof for shrink needs to contain more information, as we cannot simply state that \lstinline{t} is ordered and therefore \lstinline{sh} is ordered, there needs to be a link between the two trees. Therefore, hypotheses need to contain the result of shrinking the tree, \lstinline{shrink t = some (x, a, sh)}, and that the entire tree is ordered and therefore so is \lstinline{sh}. The proof also concludes that \lstinline{x} is larger than all of the keys in a shrunken tree.

\begin{lstlisting}
lemma shrink_ordered {t sh : btree α} {x : nat} {a : α} :
  ordered t ∧ shrink t = some (x, a, sh) →
    ordered sh ∧ forall_keys gt x sh := ...
\end{lstlisting}

This lemma, could have been be split into two separate lemmas with one concluding that \lstinline{sh} is ordered and that \lstinline{x} is greater than all keys in \lstinline{sh}. If the lemma was to be separated into two, the induction hypotheses would not be strong enough to complete the proofs.

The proof for \lstinline{shrink_ordered} was done by induction on the tree generalizing \lstinline{x}, \lstinline{a} and \lstinline{sh}.

In the inductive step, if the left subtree is larger than the height of \lstinline{sh + 1}, then \lstinline{sh = rotate_right (node l k v sh_1)}, where \lstinline{sh_1} is from \lstinline{shrink r = (x_1, a_1, sh_1)}. This case can be resolved with the lemma \lstinline{rotate_right_keys} to show that keys are preserved after a rotation. Then we need to show that all the keys in \lstinline{sh} come from the original tree, which is done by applying the lemma \lstinline{shrink_keys}.

\begin{lstlisting}
lemma shrink_keys {t sh : btree α} {x : nat} {a : α} :
  ordered t ∧ shrink t = some (x, a, sh) → 
    bound x t ∧ (∀ k', bound k' t → bound k' sh) := ...
\end{lstlisting}

We know that \lstinline{x_1} is larger than all the keys in \lstinline{sh_1}. Since \lstinline{(node l k v sh_1)} is ordered, then it must be the case that \lstinline{k} is smaller than all the keys in \lstinline{sh_1}, and therefore \lstinline{x > k} and \lstinline{x} is greater than all the keys in \lstinline{l}. This is formalized using the auxiliary lemma \lstinline{forall_shrink}.

\begin{lstlisting}
lemma forall_shrink {t sh : btree α} {k x : nat} {a : α} 
{p : nat → nat → Prop} :
  forall_keys p k t ∧ shrink t = some (x, a, sh) → 
    forall_keys p k sh ∧ p k x :=
\end{lstlisting}

As \lstinline{shrink_keys} would have to be applied to \lstinline{shrink_ordered}, the original \lstinline{forall_keys} definitions had to be rewritten. The original definition was recursed into the two subtrees, as well as looking at the relation between the input key and current node key. It presented nothing about the key being bound in the tree, even though it is intuitive and a safe assumption to make. In order to use \lstinline{shrink_keys} with \lstinline{forall_keys}, we need a definition that includes an assumption of boundedness, but still compares the input key to keys in a tree. The result was the current definition of \lstinline{forall_keys}.

After the new definition was written, a characterization lemma was needed in order to be able to work with the two different definitions, because we don't necessarily need the hypothesis that the keys compared are bound in the tree in all the proof constructions, or even in the entire proof construction.

The characterization lemma being a bi-implication allows for the lemma to be applied to any hypothesis containing a \lstinline{forall_keys}, to extract information about the subtrees separately and the relationship between \lstinline{k} and \lstinline{x}. This made proof constructions with \lstinline{forall_keys} significantly easier, as there was an alternative way to unfold \lstinline{forall_keys}, instead of unfolding it in terms of \lstinline{bound} like in the definition. 

\begin{lstlisting}
lemma forall_keys_unfolded {l r : btree α} {k x : nat} {v : α} 
{p : nat → nat → Prop} :
  (forall_keys p k l ∧ p k x ∧ forall_keys p k r) ↔ 
    forall_keys p k (node l x v r) :=
\end{lstlisting}