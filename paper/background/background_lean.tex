The Lean Theorem Prover is a proof assistant based on dependent type theory with inductive families and universe polymorphism \cite{inductive_families}. The language contains dependent function types and inductive types.

In simple type theory, every expression has an associated type -- for example, integers, booleans or functions \lstinline{α → β} where \lstinline{α} and \lstinline{β} are types. Lean's dependent type theory extends simple type theory by having types themselves be terms \cite{lean:manual}, which can be constants, variables, applications (i.e. functions) and $\lambda$-expressions.

\begin{lstlisting}[escapeinside={*}{*}]
  constant x : *$\mathbb{Z}$*
  #check λx : *$\mathbb{Z}$*, square (abs x)
\end{lstlisting}

The code above shows an example of usage of simple types. we have a constant \lstinline{x} which is an integer and a $\lambda$-expression. A $\lambda$-expression \lstinline{λx : t} with \lstinline{t : α}, is essentially a function \lstinline{x → t} where each value of \lstinline{x} is mapped to \lstinline{t}. Therefore, taking the example above, the expression would map the value denoted by 0 to \lstinline{square (abs 0)}, 1 to \lstinline{square (abs 1)} and so on.

Simple type theory allows to differentiate between certain structures of different types. For example, if we have a \lstinline{list α}, we can differentiate between a list of booleans \lstinline{list bool} or lists of integers \lstinline{list ℤ}.

Dependent types depend on \textit{terms} instead of types. If we have a function \lstinline{pick n} where the function returns a natural number between 1 and \lstinline{n}, intuitively the type becomes the set of all natural numbers up to and including \lstinline{n}. The type of \lstinline{pick} is \textit{dependent} on the type of \lstinline{n}. In this example, \lstinline{n} is the term and the set of natural number is the is the type that depends on it.

In Lean, an inductive type is has zero or more constructors, and each constructor specifies a way of building an inhabitant of the type. Below are two examples of inductive types in Lean : \lstinline{nat} and \lstinline{list}.

\begin{lstlisting}
inductive nat : Type 
| zero : nat
| succ : nat → nat

inductive list (T : Type u)
| nil : list
| cons (hd : T) (tl : list) : list
\end{lstlisting}

We can see that \lstinline{nat} has two constructors, \lstinline{zero} and \lstinline{succ}, that can be used to create new values of type \lstinline{nat}, and doesn't have any constructor arguments and is overall a pretty simple inductive type. Terms can be created from this constructor fairly simply - for example, zero is \lstinline{nat.zero}, one is \lstinline{nat.succ (nat.zero)}, and so on. The inductive type for lists has two constructors as well, for an empty list and a list with a head and a tail. This inductive type is recursive, as the constructor argument \lstinline{tl} refers to the inductive type itself \cite{lean:reference}.
