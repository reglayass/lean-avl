def tostring : btree string → string
| btree.empty := "_"
| (btree.node l k a r) := "[" ++ " " ++ to_string k ++ " " ++ tostring l ++ " " ++ tostring r ++ " " ++ "]"

def balanced : btree α → bool
| btree.empty := tt
| (btree.node l k a r) := (height r - height l) ≤ 1

def bf : btree α → nat
| btree.empty := 0
| (btree.node l k a r) :=
  height l - height r


inductive outLeft {α : Type u} : btree α → Prop
| empty {} : outLeft (btree.empty)
| node (xL xR zR : btree α) (x z : nat) (a d : α) :  
    (height xL ≥ height xR) → 
    (height xL ≤ height xR + 1) → 
    (height xR ≥ height zR) → 
    (height xL = height zR + 1) → 
    outLeft (btree.node (btree.node xL x a xR) z d zR)


def outLeft : btree α → bool
| btree.empty := ff
| (btree.node (btree.node xL x a xR) z d zR) := 
  (height xL ≥ height xR) ∧ (height xL ≤ height xR + 1) ∧ 
  (height xR ≥ height zR) ∧ (height xL = height zR + 1)
| (btree.node l k a r) := outLeft l

def outRight : btree α → bool
| btree.empty := ff
| (btree.node zL z d (btree.node yL y b yR)) :=
  (height yL ≤ height yR) ∧ (height yL ≤ height yR + 1) ∧
  (height yR ≥ height zL) ∧ (height zL + 1 = height yR)
| (btree.node l k a r) := ff

def easyR : btree α → btree α
| btree.empty := btree.empty
| (btree.node (btree.node xL x a xR) z d zR) := 
  (btree.node xL x a (btree.node xR z d zR))
| (btree.node l k a r) := btree.node l k a r

def easyL : btree α → btree α
| btree.empty := btree.empty
| (btree.node zL z d (btree.node yL y b yR)) :=
  (btree.node (btree.node zL z d yL) y b yR)
| (btree.node l k a r) := btree.node l k a r

def rotR : btree α → btree α
| btree.empty := btree.empty
| (btree.node (btree.node xL x a xR) z d zR) :=
  if (height xL < height xR) then easyR (btree.node (easyL (btree.node xL x a xR)) z d zR)
  else easyR (btree.node (btree.node xL x a xR) z d zR)
| (btree.node l k a r) := btree.node (rotR l) k a r

def rotL : btree α → btree α
| btree.empty := btree.empty
| (btree.node zL z d (btree.node yL y b yR)) :=
  if (height yR < height yL) then easyL (btree.node zL z d (easyR (btree.node yL y b yR)))
  else easyL (btree.node zL z d (btree.node yL y b yR))
| (btree.node l k a r) := btree.node l k a (rotL r)

-- lemma rotR_ordered (ll lr r : btree α) (k lk : nat) (a la : α) :
--   ordered (btree.node (btree.node ll lk la lr) k a r) → 
--     ordered (rotR (btree.node (btree.node ll lk la lr) k a r)) :=
-- begin 
--   intros h₁,
--   simp only [rotR],
--   by_cases c₁ : (height ll < height lr),
--   { simp only [if_pos c₁],
--     cases lr,
--     case empty {
--       simp only [easyL],
--       apply easyR_ordered,
--       exact h₁,
--     },
--     case node : trl trk tra trr {
--       apply easyR_ordered,
--       simp only [ordered],
--       simp only [ordered] at h₁,
--       split,
--       { split, 
--         { split,
--           { apply and.left (and.left h₁), },
--           { split, 
--             { apply and.left (and.left (and.right (and.left h₁))), },
--             { split, 
--               { finish, },
--               { sorry },
--             },
--           }, 
--         },
--         { split, 
--           { apply and.left (and.right (and.left (and.right (and.left h₁)))), },
--           { split,
--             { rw forall_keys,
--               apply and.elim h₁,
--               intros h₂ h₃,
--               apply and.elim h₂,
--               intros h₄ h₅,
--               apply and.elim h₅,
--               intros h₆ h₇,
--               apply and.elim h₇,
--               intros h₈ h₉,
--               rw forall_keys at h₉, 
--               split,
--               { apply forall_keys_trans ll (>) lk _,
--                 { apply and.left (and.right h₉), },
--                 { apply trans, },
--                 { exact h₈, }, 
--               },
--               { split, 
--                 { apply and.left (and.right h₉), },
--                 { finish, },
--               },
--             },
--             { finish, }, 
--           },
--         },
--       },
--       { split, 
--         { apply and.left (and.right h₁), },
--         { split,
--           { apply and.elim h₁,
--             intros h₂ h₃,
--             apply and.elim h₃,
--             intros h₄ h₅,
--             apply and.elim h₅,
--             intros h₆ h₇,
--             rw forall_keys, 
--             rw forall_keys at h₆,
--             clear h₂ h₃ h₄ h₅ h₇,
--             apply and.elim h₆,
--             intros h₂ h₃,
--             apply and.elim h₃,
--             intros h₄ h₅,
--             rw forall_keys at h₅,
--             rw forall_keys,
--             split,
--             { apply and.intro h₂ (and.intro h₄ (and.left h₅)), },
--             { apply and.intro (and.left (and.right h₅)) (and.right (and.right h₅)), },
--           },
--           { finish, }, 
--         },
--       },
--     },
--   },
--   { simp only [if_neg c₁], 
--     apply easyR_ordered,
--     exact h₁,
--   },
-- end
