import basic
import tactic.linarith
set_option pp.generalized_field_notation false

universe u

namespace rotation_lemmas
open btree

variables {α : Type u}

lemma forall_keys_trans (r : btree α) (p : nat → nat → Prop) (z x : nat) (h₁ : p x z) (h₂ : ∀ a b c, p a b → p b c → p a c) :
  forall_keys p r z → forall_keys p r x :=
begin
  induction r,
  case empty { simp [forall_keys], },
  case node : rl rk ra rr ihl ihr { 
    simp [forall_keys],
    intros h₃ h₄ h₅,
    split,
    { finish, },
    { split, 
      { apply h₂, apply h₁, finish, },
      { finish, },
    },
  },
end

lemma easyL_ordered (rl rr l : btree α) (k rk : nat) (a ra : α) :
  ordered (btree.node l k a (btree.node rl rk ra rr)) → 
    ordered (easyL (btree.node l k a (btree.node rl rk ra rr))) :=
begin
  intro h₁,
  simp only [easyL, ordered],
  simp only [ordered] at h₁,
  split,
  { split, 
    { apply and.left h₁, },
    { split, 
      { apply and.left (and.left (and.right h₁)), },
      { apply and.elim h₁,
        intros h₂ h₃,
        apply and.elim h₃,
        intros h₄ h₅,
        apply and.elim h₅,
        intros h₆ h₇,
        rw forall_keys at h₇,
        apply and.intro h₆ (and.left h₇), 
      },
    },
  },
  { apply and.intro,
    { finish, },
    { apply and.intro, 
      { rw forall_keys, 
        apply and.elim h₁,
        intros h₂ h₃,
        apply and.elim h₃,
        intros h₄ h₅,
        apply and.elim h₅,
        intros h₆ h₇,
        rw forall_keys at h₇,
        split,
        { apply forall_keys_trans _ (>) k _, 
          { apply and.left (and.right h₇), },
          { apply trans, },
          { exact h₆, },
        },
        { split, apply and.left (and.right h₇), finish, },
      },
      { finish, },
    } 
  },
end

lemma easyR_ordered (ll lr r : btree α) (k lk : nat) (a la : α) : 
  ordered (btree.node (btree.node ll lk la lr) k a r) → 
    ordered (easyR (btree.node (btree.node ll lk la lr) k a r)) :=
begin
  intro h₁,
  simp only [easyR, ordered],
  simp only [ordered] at h₁,
  apply and.intro,
  { apply and.left (and.left h₁), },
  { apply and.intro,
    { apply and.intro, 
      { apply and.left (and.right (and.left h₁)), },
      { apply and.intro, 
        { apply and.left (and.right h₁), },
        { apply and.intro,
          { apply and.elim h₁, 
            intros h₂ h₃,
            apply and.elim h₃,
            intros h₄ h₅,
            apply and.elim h₅,
            intros h₆ h₇,
            rw forall_keys at h₆,
            apply and.right (and.right h₆),
          },
          { finish, },
        },
      },
    },
    { apply and.intro, 
      { apply and.left (and.right (and.right (and.left h₁))), },
      { rw forall_keys, 
        apply and.intro,
        { apply and.right (and.right (and.right (and.left h₁))), },
        { apply and.elim h₁,
          intros h₂ h₃,
          apply and.elim h₃,
          intros h₄ h₅,
          apply and.elim h₅,
          intros h₆ h₇,
          rw forall_keys at h₆,
          apply and.intro,
          { apply and.left (and.right h₆), },
          { apply forall_keys_trans _ (<) k _, 
            { apply and.left (and.right h₆), },
            { apply has_lt.lt.trans, },
            { exact h₇, },
          }, 
        },
      },
    }, 
  },
end

lemma easyR_balanced (ll lr r : btree α) (lk k : nat) (la a : α) :
  outLeft (btree.node (btree.node ll lk la lr) k a r) → balanced (easyR (btree.node (btree.node ll lk la lr) k a r)) :=
begin
  sorry,
end

lemma easyL_keys (l rl rr : btree α) (k rk : nat) (a ra : α) :
  bound k (btree.node l k a (btree.node rl rk ra rr)) → bound k (easyL (btree.node l k a (btree.node rl rk ra rr))) :=
begin
  intro h,
  simp only [easyL, bound],
  simp only [bound] at h,
  by_cases c₁ :(k < k),
  { exfalso, linarith, },
  { simp only [if_neg c₁], 
    simp only [if_neg c₁] at h,
    by_cases c₂ : (k < rk),
    { simp [if_pos c₂], 
    },
    { by_cases c₃ : (k > rk),
      { sorry },
      { simp [if_neg c₂, if_neg c₃], },
    },
  },
end

lemma rotL_ordered (rl rr l : btree α) (k rk : nat) (a ra : α) :
  ordered (btree.node l k a (btree.node rl rk ra rr)) → 
    ordered (rotL (btree.node l k a (btree.node rl rk ra rr))) :=
begin
  intro h,
  simp only [rotL],
  by_cases c₁ : (height rr < height rl),  
  { simp only [if_pos c₁], 
    cases rl,
    case empty {
      simp only [easyR],
      apply easyL_ordered,
      exact h,
    },
    case node : rll rlk rla rlr {
      simp only [easyR, easyL, ordered],
      simp only [ordered] at h,
      split,
      { split, 
        { apply and.left h, },
        { split, 
          { apply and.left (and.left (and.left (and.right h))), },
          { split,
            { apply and.left (and.right (and.right h)), },
            { apply and.elim h, 
              intros h₁ h₂,
              apply and.elim h₂,
              intros h₃ h₄,
              apply and.elim h₄,
              intros h₅ h₆,
              rw forall_keys at h₆,
              rw forall_keys at h₆,
              apply and.left (and.left h₆),
            },
          },
        },
      },
      { split,
        { split, 
          { apply and.left (and.right (and.left (and.left (and.right h)))), },
          { split, 
            { apply and.left (and.right (and.left (and.right h))), },
            { split, 
              { apply and.elim h,
                intros h₁ h₂,
                apply and.elim h₂,
                intros h₃ h₄,
                apply and.elim h₃,
                intros h₅ h₆,
                rw forall_keys at h₆,
                apply and.right (and.right (and.left (and.right h₆))), 
              },
              { apply and.right (and.right (and.right (and.left (and.right h)))), },
            },
          },
        },
        { split, 
          { rw forall_keys, 
            apply and.elim h,
            intros h₁ h₂,
            apply and.elim h₂,
            intros h₃ h₄,
            apply and.elim h₄,
            intros h₅ h₆,
            rw forall_keys at h₆,
            rw forall_keys at h₆,
            split,
            { apply forall_keys_trans l (>) k _,
              { apply and.left (and.right (and.left h₆)), },
              { apply trans, },
              { apply and.left (and.right (and.right h)), }, 
            },
            { split, 
              { apply and.left (and.right (and.left h₆)) },
              { apply and.left (and.right (and.right (and.left (and.left (and.right h))))), },
            },
          },
          { rw forall_keys, 
            apply and.elim h,
            intros h₁ h₂,
            apply and.elim h₂,
            intros h₃ h₄,
            apply and.elim h₃,
            intros h₅ h₆,
            apply and.elim h₆,
            intros h₇ h₈,
            apply and.elim h₈,
            intros h₉ h₀,
            rw forall_keys at h₉,
            split,
            { apply and.right (and.right (and.right (and.left (and.left (and.right h))))), },
            { split,
              { apply and.left (and.right h₉), },
              { apply forall_keys_trans rr (<) rk _, 
                { apply and.left (and.right h₉), },
                { apply has_lt.lt.trans, },
                { exact h₀, },
              }, 
            },
          },
        }, 
      },
    },
  },
  { simp only [if_neg c₁],
    apply easyL_ordered,
    exact h,
  },
end

lemma rotR_ordered (ll lr r : btree α) (k lk : nat) (a la : α) : 
  ordered (btree.node (btree.node ll lk la lr) k a r) → 
    ordered (rotR (btree.node (btree.node ll lk la lr) k a r)) :=
begin
  intro h,
  simp only [rotR],
  by_cases c₁ : (height ll < height lr),
  { simp only [if_pos c₁], 
    cases lr,
    case empty {
      apply easyR_ordered,
      exact h,
    },
    case node : lrl lrk lra lrr {
      simp only [easyL, easyR, ordered],
      simp only [ordered] at h,
      split,
      { split, 
        { apply and.left (and.left h), },
        { split, 
          { apply and.left (and.left (and.right (and.left h))), },
          { split, 
            { apply and.left (and.right (and.right (and.left h))), },
            { apply and.elim h,
              intros h₁ h₂,
              apply and.elim h₁,
              intros h₃ h₄,
              apply and.elim h₄,
              intros h₅ h₆,
              apply and.elim h₆,
              intros h₇ h₈,
              rw forall_keys at h₈,
              apply and.left h₈,
            },
          },
        },
      },
      { split, 
        { split,
          { apply and.left (and.right (and.left (and.right (and.left h)))), },
          { split, 
            { apply and.left (and.right h), },
            { split, 
              { apply and.elim h, 
                intros h₁ h₂,
                apply and.elim h₂,
                intros h₃ h₄,
                apply and.elim h₄,
                intros h₅ h₆,
                rw forall_keys at h₅,
                rw forall_keys at h₅,
                apply and.right (and.right (and.right (and.right h₅))),
              },
              { apply and.right (and.right (and.right h)), },
            },
          }, 
        },
        { split,
          { rw forall_keys, 
            apply and.elim h,
            intros h₁ h₂,
            apply and.elim h₁,
            intros h₃ h₄,
            apply and.elim h₄,
            intros h₅ h₆,
            apply and.elim h₆,
            intros h₇ h₈,
            rw forall_keys at h₈,
            split,
            { apply forall_keys_trans ll (>) lk _, 
              { apply and.left (and.right h₈), },
              { apply trans, },
              { exact h₇, },
            },
            { split, 
              { apply and.left (and.right h₈), },
              { apply and.left (and.right (and.right (and.left (and.right (and.left h))))), },
            },
          },
          { rw forall_keys,
            apply and.elim h,
            intros h₁ h₂,
            apply and.elim h₂,
            intros h₃ h₄,
            apply and.elim h₄,
            intros h₅ h₆,
            rw forall_keys at h₅,
            apply and.elim h₅,
            intros h₇ h₈,
            apply and.elim h₈, 
            intros h₉ h₀,
            rw forall_keys at h₀,
            split,
            { apply and.right (and.right (and.right (and.left (and.right (and.left h))))), },
            { split, 
              { apply and.left (and.right h₀), },
              { apply forall_keys_trans r (<) k _, 
                { apply and.left (and.right h₀), },
                { apply has_lt.lt.trans, },
                { exact h₆, },
              },
            },
          }, 
        },
      },
    },
  },
  { simp only [if_neg c₁],
    apply easyR_ordered,
    exact h, 
  },
end

end rotation_lemmas