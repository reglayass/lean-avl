-- def inorder_succ : btree α → btree α × nat
-- | btree.empty := (btree.empty, nat.zero)
-- | (btree.node l k a r) :=
--   match l with 
--   | btree.empty := (r, k)
--   | (btree.node ll lk la lr) :=
--     have tl : btree α := btree.node ll lk la lr,
--     let (l', m) := inorder_succ l in (balance (btree.node l' k a r), m)
--   end

-- def merge : btree α → btree α → btree α
-- | btree.empty btree.empty := btree.empty
-- | (btree.node l k a r) btree.empty := btree.node l k a r
-- | btree.empty (btree.node l k a r) := btree.node l k a r
-- | (btree.node ll lk la lr) (btree.node rl rk ra rr) :=
--   have r : btree α := (btree.node rl rk ra rr),
--   have l : btree α := (btree.node ll lk la lr),
--   let (r', m) := inorder_succ r in balance (btree.node l m la r')

-- def delete (x : nat) : btree α → btree α
-- | btree.empty := btree.empty
-- | (btree.node l k a r) :=
--   if x < k then btree.node (delete l) k a r
--   else if x > k then btree.node l k a (delete r)
--   else merge l r

*******************************************************
*******************************************************
*******************************************************

def shrink : btree α → (nat × α × btree α)
| btree.empty := sorry -- idk what to do! can't shrink an empty tree
| (btree.node l k a r) :=
  have s : nat × α × btree α := shrink r,
  have st : btree α := (s.2).2,
  have x : nat := s.1,
  have v : α := (s.2).1,
  if height l > height st + 1 then (x, (v, (rotR (btree.node l k a st))))
  else (x, (v, (btree.node l k a st)))  

-- shrink preserves balance, shrink loses no keys, shrink adds no keys, shrink preserves order

def rem_root : btree α → btree α
| btree.empty := btree.empty
| (btree.node l k a r) :=
  match l with 
  | btree.empty := r
  | (btree.node ll lk la lr) :=
    have s : nat × α × btree α := shrink (btree.node l k a r),
    have st : btree α := (s.2).2,
    have x : nat := s.1,
    have v : α := (s.2).1, 
    if (height r > height st + 1) then rotL (btree.node st x v r)
    else btree.node st x v r
  end

-- rem_root preserves balance, rem_root preserves order, conserves keys

def remove (x : nat) : btree α → btree α
| btree.empty := btree.empty
| (btree.node l k a r) := 
  if x = k then rem_root (btree.node l k a r)
  else if x < k ∧ height r > height (remove l) + 1 then rotL (btree.node (remove l) k a r)
  else if height l > height (remove r) + 1 then rotR (btree.node l k a (remove r))
  else btree.node l k a (remove r)

-- preserves order, preserves balance, etc